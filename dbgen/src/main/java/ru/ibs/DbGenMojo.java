package ru.ibs;

import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;

import java.io.*;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.sql.*;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Mojo( name = "dbgen")
public class DbGenMojo extends AbstractMojo{

    private static final String FILE_MARK = "//generated by dbgen";

    @Parameter(property = "dbgen.user")
    private String user;

    @Parameter(property = "dbgen.passsword")
    private String password;

    @Parameter(property = "dbgen.url")
    private String url;

    @Parameter(property = "dbgen.outputDirectory")
    private String outputDirectory;

    @Parameter(property = "dbgen.rootPackage")
    private String rootPackage ;

    public void execute() throws MojoExecutionException
    {
        try {
            getLog().info("dbgen: Parsing database metadata.");
            Map<List<Elem>, List<Elem>> dbmeta = parseDatabaseMetadata(url, user, password, getProhibitedTablesNames());

            getLog().info("dbgen: Prepare output directory.");
            Path createdPath = prepareDirectory(outputDirectory, rootPackage);

            getLog().info("dbgen: Writing sources.");
            dbmeta.forEach((path, cols) -> processMeta(rootPackage, createdPath, path, cols));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public static List<String> getProhibitedTablesNames() throws IOException {
        try(BufferedReader reader = new BufferedReader(new InputStreamReader(DbGenMojo.class.getResourceAsStream("/prohibited_tables_names.info"))) ){
            return reader.lines().collect(Collectors.toList());
        }
    }

    public static boolean emptyStr(String str){
        return str == null || str.trim().isEmpty();
    }

    public final static String DFLT = "DEFAULT";

    private static List<Elem> getCatalogs(DatabaseMetaData meta) throws SQLException {
        List<Elem> ret = new ArrayList<>();
        ResultSet catalogsRs = meta.getCatalogs();
        while(catalogsRs.next()) {
            String cname = catalogsRs.getString("TABLE_CAT");
            if(!emptyStr(cname))
                ret.add(new Elem(cname, ElemType.CAT));
        }

        return ret;
    }

    private static Map<Elem, List<Elem>> getSchemas(DatabaseMetaData meta, List<Elem> catalogs) throws SQLException {
        if (!catalogs.stream().allMatch(Elem::isCatalog))
            throw new RuntimeException("some passed elements aren't of a catalog type");

        Map<Elem, List<Elem>> ret = new HashMap<>();
        Elem dlftCat = new Elem(DFLT, ElemType.CAT);
        ret.put(dlftCat, new ArrayList<>());
        Map<String, Elem> mappedCats = catalogs.stream().collect(Collectors.toMap(Elem::getName, Function.identity()));
        mappedCats = new HashMap<>(mappedCats);
        mappedCats.put(DFLT, dlftCat);

        ResultSet schemasRs = meta.getSchemas();
        while (schemasRs.next()) {
            String cname = schemasRs.getString("TABLE_CATALOG");
            cname = !emptyStr(cname) ? cname : DFLT;
            Elem elem = mappedCats.get(cname);

            String sname = schemasRs.getString("TABLE_SCHEM");
            if(sname.equals("public"))
                sname = DFLT;

            if(!emptyStr(sname))
                ret.get(elem).add(new Elem(sname, ElemType.SHM));
        }

        ret.entrySet().removeIf(entry -> entry.getValue().isEmpty());
        return ret;
    }

    private static List<List<Elem>> getTables(DatabaseMetaData meta, Map<Elem, List<Elem>> catSch, List<String> prohibitedTablesNames){
        if (!catSch.keySet().stream().allMatch(Elem::isCatalog))
            throw new IllegalArgumentException("some of passed elements aren't of a catalog type");

        if (!catSch.values().stream().flatMap(List::stream).allMatch(Elem::isSchema))
            throw new IllegalArgumentException("some of passed elemtns aren't of schema type");

        Map<List<Elem>, List<Elem>> mappedTables = new HashMap<>();
        catSch.forEach((cat, schs) -> {
            schs.forEach(sch -> mappedTables.putAll(processCatalogTables(cat, sch, meta)));
            mappedTables.putAll(processCatalogTables(cat, null, meta));
        });

        mappedTables.putAll(processCatalogTables(null, null, meta));

        return mappedTables.entrySet().stream().filter(entry -> !entry.getValue().isEmpty()).
                map(entry -> toCatSchmTabList(entry.getKey(), entry.getValue(), prohibitedTablesNames)).
                flatMap(List::stream).collect(Collectors.toList());

    }

    private static void logCatalogScheme(Elem cat, Elem sch){
//        System.out.println("cat: " + (cat != null ? cat.getName() : "default ") + " sch: "+(sch != null ? sch.getName() : " default"));
    }

    private static Map<List<Elem>, List<Elem>> processCatalogTables(Elem cat, Elem sch, DatabaseMetaData meta){
        try {
            ResultSet tableRs = meta.getTables(cat != null ? cat.getName() : null, sch != null ? sch.getName() : null, null, null);
            logCatalogScheme(cat, sch);
            return new HashMap<List<Elem>, List<Elem>>() {{
                put(
                        Arrays.asList(
                                cat != null ? cat : new Elem(DFLT, ElemType.CAT),
                                sch != null ? sch : new Elem(DFLT, ElemType.SHM)
                        ),
                        processTables(tableRs)
                );
            }};
        }
        catch (Exception e){
            throw new IllegalArgumentException(e);
        }
    }


    private static List<List<Elem>> toCatSchmTabList(List<Elem> catWithSch, List<Elem> tbs, List<String> prohibitedTablesNames){
        if(!catWithSch.stream().allMatch(elem -> elem.isCatalog() || elem.isSchema()))
            throw new IllegalStateException("Elements of incorrect types were passed");

        if(!tbs.stream().allMatch(elem -> elem.isTable() || elem.isSequence()))
            throw new IllegalArgumentException("Elements should be of table or sequence types");

        return tbs.stream().filter(tb -> !prohibitedTablesNames.contains(tb.getName())).
                map(tb -> Stream.concat(catWithSch.stream(), Stream.of(tb)).
                        collect(Collectors.toList())).
                collect(Collectors.toList());
    }

    private static void logTables(ResultSet tableRs){
//        List<String> colNames = Arrays.asList(
//                "TABLE_CAT", "TABLE_SCHEM", "TABLE_NAME", "TABLE_TYPE", "REMARKS",
//                "TYPE_CAT", "TYPE_SCHEM", "TYPE_NAME", "SELF_REFERENCING_COL_NAME",
//                "REF_GENERATION"
//        );
//
//        colNames.forEach(col -> {
//            try{
//               System.out.print(" " + col + ": " + tableRs.getString(col));
//            }
//            catch (Exception e){
//                System.out.print(" " + col+": failed");
//            }
//        });
//        System.out.println();
    }

    private static List<Elem> processTables(ResultSet tableRs) throws SQLException {
        List<Elem> tables = new ArrayList<>();
        while (tableRs.next()) {
            logTables(tableRs);
            String tname = tableRs.getString("TABLE_NAME");
            String ttype = tableRs.getString("TABLE_TYPE");
            if (!emptyStr(tname) && ttype != null && !ttype.contains("SYSTEM") && !ttype.contains("INDEX")) {
                ElemType tableType = null;
                if(ttype.equals("TABLE") || ttype.equals("VIEW"))
                    tableType = ElemType.TB;
                else if(ttype.equals("SEQUENCE"))
                    tableType = ElemType.SEQ;
                else throw new IllegalArgumentException("Unknown table type: " + ttype);
                tables.add(new Elem(tname, tableType));
            }
        }

        return  tables;
    }

    private static Map<List<Elem>, List<Elem>> getColumns(DatabaseMetaData meta, List<List<Elem>> catShmTb){
        Map<List<Elem>, List<Elem>> ret = new HashMap<>();
        catShmTb.forEach(tuple -> {
            try {
                Elem cat = tuple.get(0);
                Elem shm = tuple.get(1);
                Elem tb = tuple.get(2);
                ret.put(tuple, new ArrayList<>());
                if(tb.isTable()) {
                    ResultSet columnRs = meta.getColumns(
                            cat.isDefault() ? null : cat.getName(),
                            shm.isDefault() ? null : shm.getName(),
                            tb.getName(),
                            null
                    );
                    while (columnRs.next()) {
                        String cname = columnRs.getString("COLUMN_NAME");
                        String ctype = columnRs.getString("DATA_TYPE");
                        if (!emptyStr(cname))
                            ret.get(tuple).add(new Elem(cname, ElemType.COL));
                    }
                }
            }
            catch (Exception e){
               throw new RuntimeException(e);
            }
        });
//        ret.forEach((x, y) -> y.forEach(name -> System.out.print("\""+name.getName()+"\",")));

        return ret;
    }

    private static Map<List<Elem>, List<Elem>> parseDatabaseMetadata(
            String url, String user, String password,
            List<String> prohibitedTablesNames){
        try {
            Connection conn = DriverManager.getConnection(url, user, password);
            DatabaseMetaData meta = conn.getMetaData();

            return getColumns(meta, getTables(meta, getSchemas(meta, getCatalogs(meta)), prohibitedTablesNames));
        }
        catch (Exception e){
            throw new RuntimeException(e);
        }

    }

    private static void doProcess(
            Map<List<Elem>, List<Elem>> dbmeta,
            String outputDirectory,
            String rootPackage
    ) {
        try {
            Path createdPath = prepareDirectory(outputDirectory, rootPackage);
            dbmeta.forEach((path, cols) -> {
                processMeta(rootPackage, createdPath, path, cols);
            });
        }
        catch (Exception e){
            throw new RuntimeException(e);
        }
    }

    private static void processMeta(String rootPackage, Path createdPath, List<Elem> path, List<Elem> cols) {
        try {
            Elem cat = path.get(0);
            Elem shm = path.get(1);
            Elem tb = path.get(2);
            List<String> pathElems = Stream.of(cat, shm).filter(elem -> !elem.isDefault()).
                    map(Elem::getName).collect(Collectors.toList());
            String subPackage = pathElems.stream().collect(Collectors.joining("."));
            String[] pathElemsArr = pathElems.toArray(new String[pathElems.size()]);
            Path elemPath = Paths.get("", pathElemsArr);
            Path leafPackPath = Files.createDirectories(createdPath.resolve(elemPath));
            Path outputFilePath = leafPackPath.resolve(tableToClassName(tb.getName()) + ".java");
            writeFile(rootPackage, cols, tb, subPackage, outputFilePath);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private static Path prepareDirectory(String outputDirectory, String rootPackage) throws IOException {
        Path basePackagePath = Paths.get(outputDirectory, rootPackage.split("\\."));
        Path createdPath = Files.createDirectories(basePackagePath);
        removeGeneratedFiles(Paths.get(outputDirectory));
        return createdPath;
    }

    private static void writeFile(String rootPackage, List<Elem> cols, Elem tb, String subPackage, Path outputFilePath) {
        try (PrintWriter writer = new PrintWriter(Files.newOutputStream(outputFilePath,
                StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE))) {
            writer.write(FILE_MARK + "\r\n");
            writer.write("package " + Stream.of(rootPackage, subPackage).
                    filter(str -> !str.isEmpty()).collect(Collectors.joining(".")) + ";\r\n\r\n");

            writer.write("public class " +  tableToClassName(tb.getName()) + "{\r\n\r\n");
            if (tb.isTable()) {
                cols.forEach(col -> writer.write("\t public static final String "
                        + colToFieldName(col.getName()) + " = " + "\"" + col.getName() + "\";\r\n"));
            } else writer.write("\t public static final String NAME = \"" + tb.getName() + "\";\r\n");
            writer.write("\r\n\r\n}");
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private static void removeGeneratedFiles(Path createdPath) throws IOException {

        Files.walkFileTree(createdPath, new FileVisitor<Path>() {
            @Override
            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                if(Files.readAllLines(file).contains(FILE_MARK))
                    Files.delete(file);
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
                return FileVisitResult.CONTINUE;
            }
        });
    }

    private static String toUpperFirstLetter(String str){
        String first = str.substring(0, 1).toUpperCase();
        return first + str.substring(1, str.length());
    }

    private static String tableToClassName(String tableName){
        return Arrays.stream(tableName.split("_")).
                filter(str -> !str.isEmpty()).
                map(DbGenMojo::toUpperFirstLetter).
                collect(Collectors.joining()) + "_";
    }

    private static String colToFieldName(String colName){
        return colName.toUpperCase();
//       List<String> subPahts = Arrays.asList(colName.split("_"));

//       return (subPahts.get(0) + (subPahts.size() > 1 ? subPahts.subList(1, subPahts.size()).stream().
//               collect(Collectors.joining("_")) : "")).toUpperCase();
    }

    //for test
    public static void main(String[] args){
        try {
            Map<List<Elem>, List<Elem>> dbmeta = parseDatabaseMetadata("jdbc:postgresql://localhost:5432/gisgmp", "postgres", "postgres", getProhibitedTablesNames());

            Path createdPath = prepareDirectory("D://out", "ru.ibs.dbgen");

            dbmeta.forEach((path, cols) -> processMeta("ru.ibs.dbgen", createdPath, path, cols));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

}

