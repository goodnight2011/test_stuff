package ru.ibs;

import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;

import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.sql.*;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Mojo( name = "dbgen")
public class DbGenMojo extends AbstractMojo{

    private static final String FILE_MARK = "//generated by dbgen";

    @Parameter(property = "dbgen.user")
    private String user;

    @Parameter(property = "dbgen.passsword")
    private String password;

    @Parameter(property = "dbgen.url")
    private String url;

    @Parameter(property = "dbgen.outputDirectory")
    private String outputDirectory;

    @Parameter(property = "dbgen.rootPackage")
    private String rootPackage ;

    public void execute() throws MojoExecutionException
    {
        try {
            getLog().info("dbgen: Parsing database metadata.");
            Map<List<Elem>, List<Elem>> dbmeta = parseDatabaseMetadata(url, user, password);

            getLog().info("dbgen: Prepare output directory.");
            Path createdPath = prepareDirectory(outputDirectory, rootPackage);

            getLog().info("dbgen: Writing sources.");
            dbmeta.forEach((path, cols) -> processMeta(rootPackage, createdPath, path, cols));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public static boolean emptyStr(String str){
        return str == null || str.trim().isEmpty();
    }

    public final static String DFLT = "DEFAULT";

    private static List<Elem> getCatalogs(DatabaseMetaData meta) throws SQLException {
        List<Elem> ret = new ArrayList<>();
        ResultSet catalogsRs = meta.getCatalogs();
        while(catalogsRs.next()) {
            String cname = catalogsRs.getString("TABLE_CAT");
            if(!emptyStr(cname))
                ret.add(new Elem(cname, ElemType.CAT));
        }

        return ret;
    }

    private static Map<Elem, List<Elem>> getSchemas(DatabaseMetaData meta, List<Elem> catalogs) throws SQLException {
        if (!catalogs.stream().allMatch(Elem::isCatalog))
            throw new RuntimeException("some passed elements aren't of a catalog type");

        Map<Elem, List<Elem>> ret = new HashMap<>();
        Elem dlftCat = new Elem(DFLT, ElemType.CAT);
        ret.put(dlftCat, new ArrayList<>());
        Map<String, Elem> mappedCats = catalogs.stream().collect(Collectors.toMap(Elem::getName, Function.identity()));
        mappedCats = new HashMap<>(mappedCats);
        mappedCats.put(DFLT, dlftCat);

        ResultSet schemasRs = meta.getSchemas();
        while (schemasRs.next()) {
            String cname = schemasRs.getString("TABLE_CATALOG");
            cname = !emptyStr(cname) ? cname : DFLT;
            Elem elem = mappedCats.get(cname);

            String sname = schemasRs.getString("TABLE_SCHEM");
            if(sname.equals("public"))
                sname = DFLT;

            if(!emptyStr(sname))
                ret.get(elem).add(new Elem(sname, ElemType.SHM));
        }

        ret.entrySet().removeIf(entry -> entry.getValue().isEmpty());
        return ret;
    }

    private static List<List<Elem>> getTables(DatabaseMetaData meta, Map<Elem, List<Elem>> catSch){
       if(!catSch.keySet().stream().allMatch(Elem::isCatalog))
           throw new IllegalArgumentException("some of passed elements aren't of a catalog type");

       if(!catSch.values().stream().flatMap(List::stream).allMatch(Elem::isSchema))
           throw new IllegalArgumentException("some of passed elemtns aren't of schema type");

       Map<List<Elem>, List<Elem>> mappedTables = new HashMap<>();
        catSch.forEach((cat, schs) -> {
            schs.forEach(sch -> {
                try {
                    List<Elem> key = Arrays.asList(cat, sch);
                    mappedTables.put(key, new ArrayList<>());
                    ResultSet tableRs = meta.getTables(cat.getName(), sch.getName(), null, null);
                    processTables(mappedTables, key, tableRs);
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            });

            try {
                List<Elem> key = Arrays.asList(cat, new Elem(DFLT, ElemType.CAT));
                mappedTables.put(key, new ArrayList<>());
                ResultSet tableRs = meta.getTables(cat.getName(), null, null, null);
                processTables(mappedTables, key, tableRs);
            }
            catch (Exception e){
                throw new RuntimeException(e);
            }
        });

        return mappedTables.entrySet().stream().filter(entry -> !entry.getValue().isEmpty()).
                map(entry -> toCatSchmTabList(entry.getKey(), entry.getValue())).
                flatMap(List::stream).collect(Collectors.toList());

    }

    private static List<List<Elem>> toCatSchmTabList(List<Elem> catWithSch, List<Elem> tbs){
        if(!catWithSch.stream().allMatch(elem -> elem.isCatalog() || elem.isSchema()))
            throw new IllegalStateException("Elements of incorrect types were passed");

        if(!tbs.stream().allMatch(elem -> elem.isTable() || elem.isSequence()))
            throw new IllegalArgumentException("Elements should be of table or sequence types");

        return tbs.stream().map(tb -> Stream.concat(catWithSch.stream(), Stream.of(tb)).
                collect(Collectors.toList())).
                collect(Collectors.toList());
    }

    private static void processTables(Map<List<Elem>, List<Elem>> ret, List<Elem> key, ResultSet tableRs) throws SQLException {
        while (tableRs.next()) {
            String tname = tableRs.getString("TABLE_NAME");
            String ttype = tableRs.getString("TABLE_TYPE");
            if (!emptyStr(tname) && ttype != null && !ttype.contains("SYSTEM") && !ttype.contains("INDEX")) {
                ElemType tableType = null;
                if(ttype.equals("TABLE"))
                    tableType = ElemType.TB;
                else if(ttype.equals("SEQUENCE"))
                    tableType = ElemType.SEQ;
                else throw new IllegalArgumentException("Unknown table type: " + ttype);
                ret.get(key).add(new Elem(tname, tableType));
            }
        }
    }

    private static Map<List<Elem>, List<Elem>> getColumns(DatabaseMetaData meta, List<List<Elem>> catShmTb){
        Map<List<Elem>, List<Elem>> ret = new HashMap<>();
        catShmTb.forEach(tuple -> {
            try {
                Elem cat = tuple.get(0);
                Elem shm = tuple.get(1);
                Elem tb = tuple.get(2);
                ret.put(tuple, new ArrayList<>());
                if(tb.isTable()) {
                    ResultSet columnRs = meta.getColumns(
                            cat.isDefault() ? null : cat.getName(),
                            shm.isDefault() ? null : shm.getName(),
                            tb.getName(),
                            null
                    );
                    while (columnRs.next()) {
                        String cname = columnRs.getString("COLUMN_NAME");
                        String ctype = columnRs.getString("DATA_TYPE");
                        if (!emptyStr(cname))
                            ret.get(tuple).add(new Elem(cname, ElemType.COL));
                    }
                }
            }
            catch (Exception e){
               throw new RuntimeException(e);
            }
        });

        return ret;
    }

    private static Map<List<Elem>, List<Elem>> parseDatabaseMetadata(
            String url, String user, String password
    ){
        try {
            Connection conn = DriverManager.getConnection(url, user, password);
            DatabaseMetaData meta = conn.getMetaData();

            return getColumns(meta, getTables(meta, getSchemas(meta, getCatalogs(meta))));
        }
        catch (Exception e){
            throw new RuntimeException(e);
        }

    }

    private static void doProcess(
            Map<List<Elem>, List<Elem>> dbmeta,
            String outputDirectory,
            String rootPackage
    ) {
        try {
            Path createdPath = prepareDirectory(outputDirectory, rootPackage);
            dbmeta.forEach((path, cols) -> {
                processMeta(rootPackage, createdPath, path, cols);
            });
        }
        catch (Exception e){
            throw new RuntimeException(e);
        }
    }

    private static void processMeta(String rootPackage, Path createdPath, List<Elem> path, List<Elem> cols) {
        try {
            Elem cat = path.get(0);
            Elem shm = path.get(1);
            Elem tb = path.get(2);
            List<String> pathElems = Stream.of(cat, shm).filter(elem -> !elem.isDefault()).
                    map(Elem::getName).collect(Collectors.toList());
            String subPackage = pathElems.stream().collect(Collectors.joining("."));
            String[] pathElemsArr = pathElems.toArray(new String[pathElems.size()]);
            Path elemPath = Paths.get("", pathElemsArr);
            Path leafPackPath = Files.createDirectories(createdPath.resolve(elemPath));
            Path outputFilePath = leafPackPath.resolve(tableToClassName(tb.getName()) + ".java");
            writeFile(rootPackage, cols, tb, subPackage, outputFilePath);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private static Path prepareDirectory(String outputDirectory, String rootPackage) throws IOException {
        Path basePackagePath = Paths.get(outputDirectory, rootPackage.split("\\."));
        Path createdPath = Files.createDirectories(basePackagePath);
        removeGeneratedFiles(Paths.get(outputDirectory));
        return createdPath;
    }

    private static void writeFile(String rootPackage, List<Elem> cols, Elem tb, String subPackage, Path outputFilePath) {
        try (PrintWriter writer = new PrintWriter(Files.newOutputStream(outputFilePath,
                StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE))) {
            writer.write(FILE_MARK + "\r\n");
            writer.write("package " + Stream.of(rootPackage, subPackage).
                    filter(str -> !str.isEmpty()).collect(Collectors.joining(".")) + ";\r\n\r\n");

            writer.write("public class " +  tableToClassName(tb.getName()) + "{\r\n\r\n");
            if (tb.isTable()) {
                cols.forEach(col -> writer.write("\t public static final String "
                        + colToFieldName(col.getName()) + " = " + "\"" + col.getName() + "\";\r\n"));
            } else writer.write("\t public static final String NAME = \"" + tb.getName() + "\";\r\n");
            writer.write("\r\n\r\n}");
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private static void removeGeneratedFiles(Path createdPath) throws IOException {

        Files.walkFileTree(createdPath, new FileVisitor<Path>() {
            @Override
            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                if(Files.readAllLines(file).contains(FILE_MARK))
                    Files.delete(file);
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
                return FileVisitResult.CONTINUE;
            }
        });
    }

    private static String toUpperFirstLetter(String str){
        String first = str.substring(0, 1).toUpperCase();
        return first + str.substring(1, str.length());
    }

    private static String tableToClassName(String tableName){
        return Arrays.stream(tableName.split("_")).
                map(DbGenMojo::toUpperFirstLetter).
                collect(Collectors.joining()) + "_";
    }

    private static String colToFieldName(String colName){
       List<String> subPahts = Arrays.asList(colName.split("_"));
       return (subPahts.get(0) + (subPahts.size() > 1 ? subPahts.subList(1, subPahts.size()).stream().
               map(DbGenMojo::toUpperFirstLetter).
               collect(Collectors.toList()) : "")).toUpperCase();
    }

    //for test
    public static void main(String[] args){
        try {
            Map<List<Elem>, List<Elem>> dbmeta = parseDatabaseMetadata("jdbc:postgresql://localhost:5432/", "postgres", "postgres");

            Path createdPath = prepareDirectory("/home/avb/projects/test_stuff_new/ofDbGen", "ru.ibs.dbgen");

            dbmeta.forEach((path, cols) -> processMeta("ru.ibs.dbgen", createdPath, path, cols));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

}
